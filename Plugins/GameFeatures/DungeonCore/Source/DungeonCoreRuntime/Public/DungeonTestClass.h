// Generated by Attribute Generator (https://bit.ly/AttributeGenerator). MIT license.
// Part of the series 'Create a game with Unreal Lyra - Developer Bastian - https://youtube.com/@BastianDev'
#pragma once

#include "AbilitySystemComponent.h"
#include "AbilitySystem/Attributes/LyraAttributeSet.h"
#include "AbilitySystem/LyraAbilitySystemComponent.h"
#include "NativeGameplayTags.h"
#include "DungeonTestClass.generated.h"

class UObject;
struct FFrame;
#pragma region Baseclass UGameAttributeSet: CAN ONLY EXISTS ONCE IN YOUR PROJECT. IF YOU GENERATE MULTIPLE ATTRIBUTE SETS, DELETE THIS SECTION STARTING WITH THE SECOND SET (OR UNCHECK THE BOX ON THE GENRERATOR FORM ON THE NEXT SET)
/**
 * Base Class for classes generated by the AttributeSet Generator (https://bit.ly/AttributeGenerator)
 */
UCLASS(NotBlueprintable, Abstract)
class UGameAttributeSet : public ULyraAttributeSet
{
	GENERATED_BODY()
public:
	UGameAttributeSet() {}

#pragma region ADD-REMOVE AttributeSet
	/** Attaches this AttributeSet to a given ASC */
	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category = "UGameAttributeSet")
	FORCEINLINE void AttachToASC(ULyraAbilitySystemComponent* AbilitySystemComponent);

	/** Removes this AttributeSet from a given ASC. This can be dangerous if a value has not been already replicated and cannot find its corresponding AttributSet - this will crash the game!!! */
	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category = "UGameAttributeSet")
	FORCEINLINE void RemoveFromASC(ULyraAbilitySystemComponent* AbilitySystemComponent);

	/** Looks for an instance of the given AttributeSet class in the given AbilitySetComponent and returns all Attributes found in that instance with their current values */
	UFUNCTION(BlueprintCallable, Category = "UGameAttributeSet")
	FORCEINLINE TArray<FGameplayAttribute> GetAttributesForAttributeSetClass(ULyraAbilitySystemComponent* AbilitySystemComponent, TSubclassOf<UAttributeSet> AttributSetClass);
#pragma endregion
};
#pragma region Logging
/** Macro to create a log category for everything generated here */
DECLARE_LOG_CATEGORY_EXTERN(GameAttributeSet, Log, All);
#pragma endregion
#pragma endregion DELETE UNTIL HERE IF YOU USE MULTIPLE ATTRIBUTE SETS AND FORGOT TO UNCHECK THE BOX
#pragma region GameplayTags
UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_DungeonTestClass_Energy);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_DungeonTestClass_Agility);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_DungeonTestClass_Strength);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_DungeonTestClass_Shield);

#pragma endregion

/**
 * DungeonTestClass
 * Test attributes with FText
 */
UCLASS(BlueprintType)
class UDungeonTestClass : public UGameAttributeSet
{
	GENERATED_BODY()

public:
	UDungeonTestClass();

#pragma region GETTER-SETTER-INITS

#pragma region GET-SET-INIT Energy

	/** Gets current Energy's FGameplayAttribute */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Energy")
	static FGameplayAttribute GetEnergyAttribute()
	{
		static FProperty* Prop = FindFieldChecked<FProperty>(UDungeonTestClass::StaticClass(), GET_MEMBER_NAME_CHECKED(UDungeonTestClass, Energy));
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("Ge|EnergyAttribute: Returned |Energy FProperty '%s'"), *GetNameSafe(Prop));
		return Prop;
	}

	/** Gets current Energy base value (without any currently ongoing modifications */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Energy")
	FORCEINLINE float GetBaseEnergy() const
	{
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("GetEnergyAttribute: Returned Energy base value: '%d'"), Energy.GetBaseValue());
		return Energy.GetBaseValue();
	}

	/** Gets current Energy value. Current value is base value plus/minus all modifiers */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Energy")
	FORCEINLINE float GetCurrentEnergy() const
	{
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("GetEnergyAttribute: Returned Energy current value: '%d'"), Energy.GetCurrentValue());
		return Energy.GetCurrentValue();
	}

	/** Gets relative Energy value between 0 and 1. Current value is base value plus/minus all modifiers */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Energy")
	FORCEINLINE float GetRelativeEnergy() const
	{
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("GetEnergyAttribute: Returned Energy relative value: '%d'")
			, Energy.GetCurrentValue() / Energy.GetBaseValue());
		return Energy.GetCurrentValue() / Energy.GetBaseValue();
	}

	/** Sets Energy base (and current) value. Base value is the permanent base, current value is after all modifiers. Should only be called on initialization */
	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category = "DungeonTestClass|Energy")
	FORCEINLINE void SetBaseEnergy(float NewVal)
	{
		UAbilitySystemComponent* AbilityComp = GetOwningAbilitySystemComponent();
		if (ensure(AbilityComp))
		{
			AbilityComp->SetNumericAttributeBase(GetEnergyAttribute(), NewVal);
		}
		else
		{
			UE_LOG(GameAttributeSet, Error, TEXT("SetBaseEnergy: Failed to find valid ASC"));
		}
	}

	/** Each attribute corresponds to a FText to be localized */
	const FText Attributes_DungeonTestClass_Energy_DisplayName = NSLOCTEXT("DungeonTestClass", "Attributes_DungeonTestClass_Energy", "Energy");

	/** Each attribute corresponds to a gameplay tag with the format AttributeSets.YourAttributeSetName.AttributeName */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Energy")
	FORCEINLINE FGameplayTag GetGameplayTag_Energy() const;
#pragma endregion


#pragma region GET-SET-INIT Agility

	/** Gets current Agility's FGameplayAttribute */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Agility")
	static FGameplayAttribute GetAgilityAttribute()
	{
		static FProperty* Prop = FindFieldChecked<FProperty>(UDungeonTestClass::StaticClass(), GET_MEMBER_NAME_CHECKED(UDungeonTestClass, Agility));
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("Ge|AgilityAttribute: Returned |Agility FProperty '%s'"), *GetNameSafe(Prop));
		return Prop;
	}

	/** Gets current Agility base value (without any currently ongoing modifications */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Agility")
	FORCEINLINE float GetBaseAgility() const
	{
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("GetAgilityAttribute: Returned Agility base value: '%d'"), Agility.GetBaseValue());
		return Agility.GetBaseValue();
	}

	/** Gets current Agility value. Current value is base value plus/minus all modifiers */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Agility")
	FORCEINLINE float GetCurrentAgility() const
	{
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("GetAgilityAttribute: Returned Agility current value: '%d'"), Agility.GetCurrentValue());
		return Agility.GetCurrentValue();
	}

	/** Gets relative Agility value between 0 and 1. Current value is base value plus/minus all modifiers */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Agility")
	FORCEINLINE float GetRelativeAgility() const
	{
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("GetAgilityAttribute: Returned Agility relative value: '%d'")
			, Agility.GetCurrentValue() / Agility.GetBaseValue());
		return Agility.GetCurrentValue() / Agility.GetBaseValue();
	}

	/** Sets Agility base (and current) value. Base value is the permanent base, current value is after all modifiers. Should only be called on initialization */
	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category = "DungeonTestClass|Agility")
	FORCEINLINE void SetBaseAgility(float NewVal)
	{
		UAbilitySystemComponent* AbilityComp = GetOwningAbilitySystemComponent();
		if (ensure(AbilityComp))
		{
			AbilityComp->SetNumericAttributeBase(GetAgilityAttribute(), NewVal);
		}
		else
		{
			UE_LOG(GameAttributeSet, Error, TEXT("SetBaseAgility: Failed to find valid ASC"));
		}
	}

	/** Each attribute corresponds to a FText to be localized */
	const FText Attributes_DungeonTestClass_Agility_DisplayName = NSLOCTEXT("DungeonTestClass", "Attributes_DungeonTestClass_Agility", "Agility");

	/** Each attribute corresponds to a gameplay tag with the format AttributeSets.YourAttributeSetName.AttributeName */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Agility")
	FORCEINLINE FGameplayTag GetGameplayTag_Agility() const;
#pragma endregion


#pragma region GET-SET-INIT Strength

	/** Gets current Strength's FGameplayAttribute */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Strength")
	static FGameplayAttribute GetStrengthAttribute()
	{
		static FProperty* Prop = FindFieldChecked<FProperty>(UDungeonTestClass::StaticClass(), GET_MEMBER_NAME_CHECKED(UDungeonTestClass, Strength));
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("Ge|StrengthAttribute: Returned |Strength FProperty '%s'"), *GetNameSafe(Prop));
		return Prop;
	}

	/** Gets current Strength base value (without any currently ongoing modifications */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Strength")
	FORCEINLINE float GetBaseStrength() const
	{
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("GetStrengthAttribute: Returned Strength base value: '%d'"), Strength.GetBaseValue());
		return Strength.GetBaseValue();
	}

	/** Gets current Strength value. Current value is base value plus/minus all modifiers */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Strength")
	FORCEINLINE float GetCurrentStrength() const
	{
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("GetStrengthAttribute: Returned Strength current value: '%d'"), Strength.GetCurrentValue());
		return Strength.GetCurrentValue();
	}

	/** Gets relative Strength value between 0 and 1. Current value is base value plus/minus all modifiers */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Strength")
	FORCEINLINE float GetRelativeStrength() const
	{
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("GetStrengthAttribute: Returned Strength relative value: '%d'")
			, Strength.GetCurrentValue() / Strength.GetBaseValue());
		return Strength.GetCurrentValue() / Strength.GetBaseValue();
	}

	/** Sets Strength base (and current) value. Base value is the permanent base, current value is after all modifiers. Should only be called on initialization */
	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category = "DungeonTestClass|Strength")
	FORCEINLINE void SetBaseStrength(float NewVal)
	{
		UAbilitySystemComponent* AbilityComp = GetOwningAbilitySystemComponent();
		if (ensure(AbilityComp))
		{
			AbilityComp->SetNumericAttributeBase(GetStrengthAttribute(), NewVal);
		}
		else
		{
			UE_LOG(GameAttributeSet, Error, TEXT("SetBaseStrength: Failed to find valid ASC"));
		}
	}

	/** Each attribute corresponds to a FText to be localized */
	const FText Attributes_DungeonTestClass_Strength_DisplayName = NSLOCTEXT("DungeonTestClass", "Attributes_DungeonTestClass_Strength", "Strength");

	/** Each attribute corresponds to a gameplay tag with the format AttributeSets.YourAttributeSetName.AttributeName */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Strength")
	FORCEINLINE FGameplayTag GetGameplayTag_Strength() const;
#pragma endregion


#pragma region GET-SET-INIT Shield

	/** Gets current Shield's FGameplayAttribute */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Shield")
	static FGameplayAttribute GetShieldAttribute()
	{
		static FProperty* Prop = FindFieldChecked<FProperty>(UDungeonTestClass::StaticClass(), GET_MEMBER_NAME_CHECKED(UDungeonTestClass, Shield));
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("Ge|ShieldAttribute: Returned |Shield FProperty '%s'"), *GetNameSafe(Prop));
		return Prop;
	}

	/** Gets current Shield base value (without any currently ongoing modifications */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Shield")
	FORCEINLINE float GetBaseShield() const
	{
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("GetShieldAttribute: Returned Shield base value: '%d'"), Shield.GetBaseValue());
		return Shield.GetBaseValue();
	}

	/** Gets current Shield value. Current value is base value plus/minus all modifiers */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Shield")
	FORCEINLINE float GetCurrentShield() const
	{
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("GetShieldAttribute: Returned Shield current value: '%d'"), Shield.GetCurrentValue());
		return Shield.GetCurrentValue();
	}

	/** Gets relative Shield value between 0 and 1. Current value is base value plus/minus all modifiers */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Shield")
	FORCEINLINE float GetRelativeShield() const
	{
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("GetShieldAttribute: Returned Shield relative value: '%d'")
			, Shield.GetCurrentValue() / Shield.GetBaseValue());
		return Shield.GetCurrentValue() / Shield.GetBaseValue();
	}

	/** Sets Shield base (and current) value. Base value is the permanent base, current value is after all modifiers. Should only be called on initialization */
	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category = "DungeonTestClass|Shield")
	FORCEINLINE void SetBaseShield(float NewVal)
	{
		UAbilitySystemComponent* AbilityComp = GetOwningAbilitySystemComponent();
		if (ensure(AbilityComp))
		{
			AbilityComp->SetNumericAttributeBase(GetShieldAttribute(), NewVal);
		}
		else
		{
			UE_LOG(GameAttributeSet, Error, TEXT("SetBaseShield: Failed to find valid ASC"));
		}
	}

	/** Each attribute corresponds to a FText to be localized */
	const FText Attributes_DungeonTestClass_Shield_DisplayName = NSLOCTEXT("DungeonTestClass", "Attributes_DungeonTestClass_Shield", "Shield");

	/** Each attribute corresponds to a gameplay tag with the format AttributeSets.YourAttributeSetName.AttributeName */
	UFUNCTION(BlueprintPure, Category = "DungeonTestClass|Shield")
	FORCEINLINE FGameplayTag GetGameplayTag_Shield() const;
#pragma endregion


#pragma endregion

protected:
#pragma region Replication
	UFUNCTION()
	void OnRep_Energy(const FGameplayAttributeData& OldValue);

	UFUNCTION()
	void OnRep_Agility(const FGameplayAttributeData& OldValue);

	UFUNCTION()
	void OnRep_Strength(const FGameplayAttributeData& OldValue);

	UFUNCTION()
	void OnRep_Shield(const FGameplayAttributeData& OldValue);


#pragma endregion

#pragma region Event pre and post Gameplay Effects
	// events pre or post applying a Gameplay Effect
	virtual void PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data) override;
	// events pre or post applying an Attribute change
	virtual void PreAttributeBaseChange(const FGameplayAttribute& Attribute, float& NewValue) const override;
	virtual void PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue) override;
	virtual void PostAttributeChange(const FGameplayAttribute& Attribute, float OldValue, float NewValue) override;
	virtual void OnAttributeAggregatorCreated(const FGameplayAttribute& Attribute, FAggregator* NewAggregator) const override;
#pragma endregion

	// helper function to make sure that the attribute stays between zero and max
	void ClampAttribute(const FGameplayAttribute& Attribute, float& NewValue) const;

private:

	// one property per attribute
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Energy, Category = "DungeonTestClass", Meta = (AllowPrivateAccess = true))
	FGameplayAttributeData Energy;

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Agility, Category = "DungeonTestClass", Meta = (AllowPrivateAccess = true))
	FGameplayAttributeData Agility;

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Strength, Category = "DungeonTestClass", Meta = (AllowPrivateAccess = true))
	FGameplayAttributeData Strength;

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Shield, Category = "DungeonTestClass", Meta = (AllowPrivateAccess = true))
	FGameplayAttributeData Shield;


};